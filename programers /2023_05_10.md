## Today's solution

---


### 1. 추억 점수

```python
def solution(name, yearning, photo):
    answer = []
    tmp = {} # 딕셔너리를 통해 사람당 그리움을 지정한다. 
    
    for i in range(len(name)):
        tmp[name[i]] = yearning[i]
    
    for i in photo: # photo 배열에는 여러개의 사진이 들어있음. 사진 하나당
        score = 0 #사진 하나당 스코어 계산
        for j in i: #사진 하나에 사람 한명씩 탐색하며
            if j in tmp: #딕셔너리에 있다면 == 그리움 점수가 있다면 
                score += tmp[j]
            
        answer.append(score)
    
    
    return answer

```

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/176963)

🤔 Discussion

1. Dict을 만드는 과정에서 같은 배열의 len만큼 도는 과정 을 dictionary = dict(zip(name,yearning)) 처럼 조금 더  
    간단하게 표현 가능할 듯 하다. 


### 2. 소수 찾기 

```python
def solution(n):
    answer = 0
    
    for i in range(3,n+1):
        if check_num(i):
            answer +=1
    
    return answer+1

def check_num(n):
    flag = True
    for i in range(2, int(n**0.5)+1):
        if n % i ==0:
            flag = False
            return flag
            break
    return flag


```

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12921)

🤔 Discussion 

1. 소수 판별 알고리즘으로 2~n-1까지 나눠보기 
2. 2~ n//2까지 나눠보기 
3. 2~ n**(0.5) 까지 탐색하기가 존재한다. 


```python
def solution(n):
    num=set(range(2,n+1))

    for i in range(2,n+1):
        if i in num:
            num-=set(range(2*i,n+1,i))
    return len(num)

```
✔️ 알고리즘 구현하는 방식 하나 더 기억해 두자. 
